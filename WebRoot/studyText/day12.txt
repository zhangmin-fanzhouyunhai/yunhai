回顾：
jsp:
cookie:
	浏览器端会话技术
	由服务器产生，生成key=value形式，通过响应头（set-cookie)返回
	给浏览器，保存在浏览器端
	下次访问的时候根据一定的规则携带cookie，通过请求头(cookie)携带给服务器
	常用方法：
		构造：
			new Cookie(String key,String value)
		写回：
			response.addCookie(Cookie c)
		获取：
			Cookie[] request.getCookies()
		cookie的api:
			getName():获取cookie的名称
			getValue():获取cookie的值
			setMaxAge(int)
			setMaxAge(int 秒数);持久化
				若int为0；删除此cooike(前提必须路径一致)
			setPath(String path)；设置cookie的路径
				若访问的链接的路径 中包含cookie的path，则携带
	注意：
		cookie不能跨浏览器
		cookie不支持中文
/////////////////////////////////////////////////				
session:
	服务器的会话技术
	浏览器访问服务器的时候，服务器会获取jessionid,
		若获取不到：
			服务器创建一个session，保存用户数据，
			将该session的jsessionid通过响应返回给浏览器
		若获取到
			服务器拿着这个jessionid去session池中查找有无此session
				若查找不到：
					服务器创建一个session,保存用户数据，将该session的jsessionid通过响应返回给浏览器
				若查找到：
					拿过来直接使用，将该session的jsessionid通过响应返回给浏览器
	常用方法：
		获取一个session
			request.getSession();
		
	session域对象：
		xxxAttribute()
		生命周期：
			创建：java程序中第一次使用request.getSession方法的时候
			销毁：
				服务器非正常关闭
				session超时
					默认时间
					手动设置时间
				手动删除*（一颗星）
					session.invalidate();
	域对象：
		ServletContext:共享的数据
		HttpServletRequest:一次请求的数据
		HttpSession:私有的数据
///////////////////////////////////////////////
jsp/el/jstl
案例1-在页面中展示所有商品信息，不要使用jsp的脚本
技术分析：
	jsp/el/jstl
/////////////////////////////////////////////////////
jsp:
	java 服务器页面
	作用：
		将内容的生成和信息的展示相分离
	运行在服务器商，本质上就是一个servlet,产生的java文件和
	class保留在tomcat的word目录下。
jsp脚本：
	<%..%>java代码片段
	<%=..%>输出表达式	相当于out.print();
	<%!...%>声明成员
jsp的指令
	作用：声明jsp页面的一些属性和动作
	格式：
		<%@指令名称	属性=“值”	属性=“值”%>
	jsp指令的分类
		page:主要声明jsp页面的一些属性
		include:静态包含。
		taglib:导入标签库
	注意：
		一个页面中可以出现多个指令
		指令可以放在任意位置，一般都放在jsp页面最上面。
//////////////////////////////////////////////////
	page指令：
		重要属性：3个
			contentType:设置响应流的编码，及通知浏览器用什么编码打开，
			设置文件的mimetype
			pageEncoding:设置页面的编码
			import:导入所需要的包
			contentType和pageEncoding联系：
				若两者都出现的时候，各自使用各自的编码
				若只出现一者，两个都使用出现的这个编码
				若两者都不出现，使用服务器默认的编码	tomcat7使用的iso-8859-1
		了解属性：
			language:当前jsp页面里面可以嵌套的语言
			buffer="8kb" :设置jsp页面的流的缓冲区的大小
			autoFlush="true":是否自动刷新
			extends:声明当前jsp的页面继承于哪个类，
			必须继承的是httpservlet 及其子类
			session:设置jsp页面是否可以使用session内置对象
			isELIgnored="false"：是否忽略EL语言
			errorPage="":前jsp面出F常的r候要跳D到的jsp面。
			isErrorPage="false":前jsp面是否是一e`面。
				若值true，可以使用jsp面的一戎 ο exception
			取值不true，to法使用exception.getMessage() 
	include指令：
		oB包含，就是⑵渌面或者servlet的热莅含M恚一起M行g\行，
		生成一java文件。
		格式：
			<%@include file="相β交蛘呤炔柯"%>
		例如
			<%@include file="/projectLearn/day11/include/i1.jsp"%>
			
		路剑
			相β剑
				./或者什麽都不 前路
			^β剑
				fh和主C的^β
				不fh和主C的^β
					/目名/Y源
					
			炔柯剑
				不fh和主C的^β饺サ繇目名
					求Dl	oB包含	B包含
					
	taglib指令：入嘶`
		格式：
			<%@taglib  prefix="前Y名" uri="名Q空g"%>
		若入之後
			<前Y名：嘶`...>
		例如：
			<c:if test=""></c:if>
			<%@taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %>
			

jsp的内置对象3w星***(9大戎ο)
	在jsp面上可以直接使用的ο
		戎ο				型
		(1)out				JSPWriter
		(2)request			HttpServletRequest
		(3)response			HttpServletResponse
		(4)session			HttpSession
		
		(5)exception		Throwable
		
		(6)page				Servlet(this)
		(7)config			ServletConfig
		(8)application		ServletContext
		
		(9)pageContext		PageContext
	jsp的域对象
		application		由 |	整目
		session			大 |	一次
		request			到 |	一次求
		pageContext		小V	一面
	pageContext作用：理解
		1.域ο
			xxxAttribute()
		2.操作其它的ο
			方法：
				xxxAttribute(...,int scope);
					scope取值：
						APPLICATION_SCOPE
						SESSION_SCOPE
						REQUEST_SCOPE
						PAGE_SCOPE
		3.获取其他的内置对象
			getXxx()
			注意：
				getRequest():获取request内置对象
		4.便捷查找
			findAttribute(String key):
				依次从pageContext,request,session,application
				四个域中，查找相应的属性，若查找到了返回值，且结束该次查找。
				若查找不到，返回一个null
jsp的动作标签
	<jsp:forward>:请求转发	相当于java中	request.getRequestDispatcher(..).forward(..);
		<jsp:forward page="内部路径（/projectLearn/day12/action/for1.jsp）"></jsp:forward>
	<jsp:include>:动态包含
		就是将被包含页面或者servlet的运行结果包含到当前页面中
//////////////////////////////////////////////////////////
el:
	jsp的内置表达式语言，从jsp2.0开始。
	用来替代<%=..%>
	作用：
		1.获取域中数据*（重点）
		2.执行运算*（重点）
		3.获取常见的web对象
		4.调用java的方法
	格式：
		${el表达式}
		
获取域中数据：*（重点）
	注意：*（重点）
		若属性名中出现了“.”|“+”|“-”等特殊符号，需要使用scope获取
			例如：
				${request.Scope["arr.age"]}
	获取简单数据
		${pageScope|requestScope|sessionScopt|applicationScope.属性名}
		以后经常使用：
			${属性名}：依次从pageContext,request,session,application查找
			指定属性，若查找到返回值，结束查找。
				若查找不到，返回空字符串""
	获取复杂数据
		获取数组中的数据
			${域中的名称[index]}
		获取list中的数据
			${域中的名称[index]}
		获取map中的数据
			${域中的名称.键名}
	javabean导航
		javabean:
			java语言编写的一个可重用的组件，
			狭义上来说就是我们编写的一个普通的java类	例如：User	Person
			javabean规范：
				1.必须是一个公共的具体的类	public class
				2.提供私有的字段		private	String id;//称之为字段
				3.提供公共访问的方式	get|set|is方式
					public String getId(){..}
					一旦有公共的方法之后，get|set|is之后的内容，
					将首字母小写，将这个东西称之为bean属性
						id就是一个bean属性
				4.提供一个无参的构造器
				5.一般实现序列化接口	serializable
				
		${域中javabean名称.bean属性}
		
////////////////////////////////////
执行运算：
	四则运算	关系(>..)	逻辑(&& ||)
	注意：
		+：只能进行加法运算，	字符串形式数字可以进行加法运算，不能做拼接运算
		empty:判断一个容器的长度是否为0（array set list map (collect)),还
			可以判断一个对象是否为空
			${empty 域中的对象名称}
		三元运算：
		
//////////////////////////////////////////////
e1的内置对象（了解）
	11个
		pageScope
		requestScope
		sessionScope
		applicationScope
		
		param
		paramValues
		
		header
		headerValues
		
		initParam
		
		cookie*（重点）
		
		pageContext*（重点）
		
	注意：
		除了pageContext其余对象获取的全是map集合
	
	了解：和参数相关的el内置对象
		param
		paramValues
		
	了解：和请求头相关的el内置对象
		header
		headerValues
		
	了解：和全局初始化参数相关的el内置对象
		initParam
	
	cookie内置对象
		${cookie}	获取map{key=Cookie}
			例如：创建cookie
				Cookie cookie=new Cookie("username","tom");
			通过${cookie}获取
				{username=new Cookie("username","tom")}
			相当于map的key是cookie的键
			map的value是当前cookie
			
		若项获取名称username的cookie的value值（获取tom)
			${cookie.username.value}--javabean导航
		注意：
			java中Cookie的api
				getName():获取cookie的名称
				getValue():获取cookie的value值
			我们称name和value是cookie的bean属性
			
		使用cookie内置对象
			${cookie.给cookie起名字.value}
			
		例如：
			获取jsession的值
			${cookie.JESSIONID.value}
			
	pageContext:获取不是map集合，相当于jsp的pageContext内置对象
			在jsp页面中获取项目名
			${pageContext.request.contextPath}
			
/////////////////////////////////////
////////////////////////////////////////
jsp注释：
	html注释 <!--  -->
		注释的内容只在页面上看不到	java代码和html源代码都有
	java注释
		只在java代码中存在
	jsp注释<%--   --%>
		只在jsp页面中存在，翻译成java文件之后就没有了，html源代码中亦没有
/////////////////////////////////////////////
/////////////////////////////////////////////
jstl:
	jsp标准的标签库语言
	apach提供
	用来替代java脚本
	使用步骤：
		1.导入jar包（jstl.jar和standard.jar)
		2.在页面上导入标签库
			<%@taglib prefix="" uri=""%>
	jstl的分类：
		core：核心类库 *（重点）
		fmt:格式化|国际化
		xml:过时了
		sql:过时了
		函数库：很少使用
	core:掌握
		（13个标签，几乎不用）
		*c:if（重点）
		*c:forEach（重点）
		
		c:set	往域中设置值
		c:choose	c:when c:otherwise 分支
		
	（重点）c:if	判断
		<c:if test="${el表达式}">满足的时候输出的内容
		
		</c:if>
	<c:if test="${3>4 }">
		3大于4
	</c:if>
	<c:if test="${3<=4 }">
		3不大于4
	</c:if>
			
	（重点）c:forEach	循环
		格式1：
			<c:forEach begin="从哪里开始" end="到哪里结束" step="步长" var="给变量起个名字" varStatus="循环状态变量">
				${i }--${vs.count }--${vs.current }<br>
			</c:forEach>
		varStatus:用来记录循环的状态
			常用的属性
				count:记录次数
				current:当前遍历的内容			
		例如：
			<c:forEach begin="1" end="50" step="2" var="i" varStatus="vs">
				${i }--${vs.count }--${vs.current }<br>
			</c:forEach>
扩展：
	c:set	和	c:choose
	函数库：
///////////////////////////////////////////////////////
案例1-步骤分析：
	1.数据库和表
			
CREATE TABLE PRODUCT(
	ID VARCHAR2(100) PRIMARY KEY ,
	PNAME NVARCHAR2(60),
	PRICE NUMBER(17,3),
	PDESC NVARCHAR2(60)
);

CREATE OR REPLACE TRIGGER PRODUCT_ID_TRI --
BEFORE INSERT ON PRODUCT --
FOR EACH ROW --
BEGIN --
SELECT --
SYS_GUID() --
INTO :NEW.ID  --
FROM DUAL ;

END PRODUCT_ID_TRI --
;

INSERT INTO PRODUCT VALUES (null,'电视机',3200,'液晶曲面大电视');
INSERT INTO PRODUCT VALUES (null,'韭菜盒子',3,'味重请小心食用');
INSERT INTO PRODUCT VALUES (null,'益达',10,'韭菜伴侣');
INSERT INTO PRODUCT VALUES (null,'十三香',12,'守义牌');
		
新建一个项目
	导入jar包：
	驱动	dbutils	c3p0	jstl	
	导入c3p0配置文件	和工具类
	实体类：
	
	2.index.jsp中添加一个连接
		<a href="/Day29/findAllProduct">展示所有商品</a>
	3.FindProductAllServlet:
		调用ProductService.findAll() 返回一个集合	List<Product>
		将list放入request域中
		请求转发到productList.jsp
	4.ProductService.findAll()	调用dao.findAll()
	5.dao.findAll()	使用beanListHandler()
	6.在productList.jsp展示所有商品
		使用<c:forEach></c:forEach>
		使用javaBean导航获取里面的数据


/////////////////////////////////////////////
案例2-重写登录案例
需求：
	在页面上填写用户名和密码及验证码，点击提交，先校验验证码是否一致。
	若一致后再去找数据库，顺便把用户名记住
技术：
	表单
	验证码
	servlet
	request
	session
	cookie
步骤分析：
	1.数据库和表
		create table user(
			ID INT primary key auto_increase,
			username VARCHAR(20),
			PASSWORD VARCHAR(20)
		)
		
	2.创建一个项目
		包结构
		jar包
		工具类和配置文件
	3.表单 login.jsp
	4.表单提交 loginServlet
		loginServlet:
			获取验证码（从前台传过来和session中）
				判断两个验证码是否一致
					若不一致：
						填写错误信息，请求转发到login.jsp
					若一致：获取用户名和密码
						调用userService的getUserByUserNameAndPassword 返回值 User user
						判断返回值 user 是否为空
							若为空：填写错误信息，请求转发到login.jsp
							若不为空：
								继续判断是否勾选了“记住用户名”
									若勾选：
										创建 cookie 将用户名放入 cookie 写回浏览器
								将user对象放入session中
								页面重定向 index.jsp 展示 xxx 欢迎回来
								
								
								
	


		
		
		
		
		
		
		
			
			


