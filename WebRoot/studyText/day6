



DB2           IBM           大型的收费的数据库
sqlserver     微软          中大型的收费的数据库
sybase        sybase(powerdesigner)

安装了数据库管理系统的计算机称之为数据库服务器
		服务器：给别人提供服务的电脑（软件服务器）
我们可以通过标准的sql在服务器创建数据库（database）
有了数据库之后，就可以在数据库上创建表了
有了表之后，就可以在里面存放数据了。
SQL：
		结构化查询语句
		作用：
				管理数据库
sql的分类：
		DDL:数据定义语言
				操作对象：数据库和表
				关键词：create alter drop
				create table 表名（字段描述，字段描述）；
				字段描述：
						字段名称  字段类型 [约束]
						例如：
								create table user(
										id int primary key auto_increment,
										username varchar(20)
										);
										
				
				修改表
						格式：
								alter table 表名 ...
						修改表名：
								alter table 旧表名 rename to 新表名；
								例如：
										alter table user1 rename to user10;
						
						添加字段
						    alter table 表名 add [column] 字段描述；
						    例如：
						    		alter table user add password varchar(20);
						修改字段名
								alter table 表名 change 字段名称 新字段名称
								例如：
										alter table user change password pwd
						修改字段描述：
								alter table 表名 modify 字段名称 字段类型 [约束]；
								例如：
										alter table user modify pwd int;
						删除字段：
						alter table 表名 drop 字段名
								例如：
										alter table user drop pwd;
						删除表
								drop table 表名
								例如：
										drop table user;
						常用命令：
								切换或者进入数据库：use 数据库名称；
								查看当前数据库下所有表：show tables;
								查看表结构desc表名；
								查看建表语句：show create table 表名;
								
		DML:数据操作语言
				操作对象：记录
		DQL:数据查询语言（非官方）
				
		DCL:数据控制语言
				操作对象：用户	事务	权限
				
				
//////////////////////////////////////////////////////////////
		DDL:数据定义语言
				操作对象：数据库和表
				关键词：create alter drop
				操作数据库
					创建：
							格式：
									create database 数据库名称
					删除：
					常用的命令：
							查看所有的数据库：show databases;
		

//////////////////////////////////////////////
DML:数据操作语言
	操作对象：记录（行）
	关键词：insert update delete
	插入：
		格式1：
			insert into 表名 values(字段值1，字段2...，字段值n);
			注意：
				默认插入全部字段，
				必须保证values后面的内容的类型和顺序和表结构中的一致
			例如：
				insert into user values(1,'tom');
				insert into user values('2','tom');
				insert into user values('3');-- 错误的
		格式2：
			insert into 表名（字段名，字段名1...) values(字段值，字段值1...);
			注意：
				插入指定的字段
				必须保证Values后面的内容的类型和顺序和表名后面的字段的顺序一样
			例如：
				insert into user (username,id) values('jack',4);
				insert into user (username) values('jack',4);-- 错误的
				
					
				
	修改：
		格式：
			update 表名 set 字段名=字段值，字段名1=字段值1... [where 条件];
		例如：
			update user set username='jerry' where username='jack';
			
	删除：
		格式：
			delete from 列名 [where 条件]
		例如：
			delete from user  where id='2' ;
			
////////////////////////////////////			
DQL:数据查询语言
		关键词：select 
	格式：
		select ... from 表名 where 条件 group by 分级字段 having 条件  order by 排序字段 asc|desc
	create table category(
	cid int primary key auto_increment,
	cname varchar(20)
);
	
create table products(
	pid int primary key auto_increment,
	pname varchar(20),
	price double,
     pnum int,
     cno int,
	pdate timestamp
);

insert into products values (null,'泰国大榴莲',98,12,1,null);
insert into products values (null,'新疆大枣',38,123,1,null);
insert into products values (null,'新疆切糕',68,50,2,null);
insert into products values (null,'十三香',10,200,3,null);
insert into products values (null,'老干妈',20,180,3,null);
insert into products values (null,'豌豆黄',20,120,2,null);
					
练习：
1.查询所有的商品
	select * from products;
2.查询商品和商品价格。
	-- 查看指定的字段
	-- 格式： select 字段名1，字段2 from 表名
	select pname,price from products;
3.查询所有商品都有那些价格。
	-- 去重操作	distinct
	-- 格式： select distinct 字段名，字段名2 from 表名
	select price from products;
	select distinct price from products;
4.将所有商品的价格+10元进行显示。（别名）
	-- 可以在查询的结果之上进行运算，不影响数据库中数据
	-- 给列起别名 格式：字段名 [as] 别名
	select price+10 from products;
	select price+10 新价格 from products;
	select price+10 '新价格' from products;
	select price+10 新 价 格 from products; -- 错误
	select price+10 '新 价 格' from products;
	select price+10 `新 价 格` from products;
	
条件查询：
练习：
1.查询商品名称为十三香的商品所有信息：
	select * from products where pname='十三香';
2.查询商品价格>60元的所有的商品信息：
	select * from products where price>60;
3.查询商品名称中包含“新”的商品
	-- 模糊匹配
	-- 格式： 字段名  like "匹配规则";
	--  匹配内容 %
			"龙"		值为龙
			"%龙"	值为以“龙”结尾
			"龙%"		值以“龙”开头
			"%龙%"	值包含"龙"
	--	匹配个数 "__"  占两个位置
	select * from products where pname like "%新%";
4.查询价格为38，68，98的商品
	select * from products where price = 38 or price =68 or price=98;
	select * from products where price in (38,68,98);
	
	where后的条件写法：
		*>,<,=,>=,<=,<>
		*like 使用占位符 _ 和 % _ 代表一个字符 %代表任意个字符。
			* select * from products where pname like '%新%';
		* in 在某个范围中获得值。
			* select * from products where pid in (2,5,8);
		* between 较小值 and 较大值
			* select * from products where price between 50 and 70;
	
	排序查询：
	1.查询所有的商品，按价格进行排序。（asc-升序，desc-降序）
		select * from products order by price desc;
	2.查询名称有新的商品的信息并且按价格不愿意吃排序。
		select * from products where pname like '%新%' order by price desc;
	
	
	聚合函数
	        对一列进行计算，返回值是一个
	* sum(),avg(),max(),min(),count();
	1.获得所有商品的价格的总和；
		select sum(price) from products;
	2.获得商品表中价格的平均数；
		select avg(price) from products;
		-- round(值，保留小数位）
		select round(avg(price),2) from products;
	3.获得商品表中有多少条记录；
		select count(pid) quantity from products;
	
	分组：使用group by 
	1.根据cno字段分组，分组后统计商品的个数
		select cno,count(*) quantity from products group by cno;
	2.根据cno分组，分组统计每组商品的总数量，并且总数量>200;
		select cno,sum(pnum) pnum from products group by cno;
		select cno,sum(pnum) pnum from products group by cno  having sum(pnum)>200;
		注意：
			where和having 区别：
				1.where 是对分组前的数据进行过滤；having 是对分组后的数据进行过滤
				2.where 后面不能使用聚合函数，having 可以
/////////////////////////////////////////		
数据类型：
java				mysql
byte				tinyint
short				smallint
int					int(*)
long				bigint
char/String			varchar(*)|char()
					varchar:可变长度	mysql的方言	varchar(20):	存放abc	只会占用三个
					char:固定长度	char(20)	存放abc	占用20个	%比较浪费空间
boolean				tinyint|int	代替
float|double		float|double
						注意
							double(5,2):该小数长度为5，小数占2个。最大值：999.99

java.sql.Date		date			日期
java.sql.Time		time			时间
java.sql.Timestamp	timestamp（*）	时间戳	左路给定值为null，数据库会把当前的系统时间存放到数据库中
					datetime（*）		日期+时间
					
java.sql.Clob(长文本)	mysql的方言（text)	
java.sql.Blob(二进制)	blob
//////////////////////////////////////////////////////
约束：
	作用：
		为了保证数据的有效性和完整性
	mysql中常用的约束：主键约束（primary key）	唯一约束（unique）  非空约束（not null）	外键约束（foreign key）
	主键约束：被修饰过的字段唯一非空
		注意：一张表只能有一个主键，这个主键可以包含多个字段
		方式1：建表的同时添加约束	格式：字段名称	字段类型	primary key
		方式2：建表的同时在约束区域添加约束	格式：primary key
			所有的字段声明完成之后，就是约束区域了
			格式：primary key(字段1，字段2)
			
			create table pk01(
				id int,
				username varchar(20),
				primary key(id)
			);
			insert into pk01 value(1,'tom');-- 成功
			insert into pk01 value(1,'tom');-- 失败  Duplicate entry '1' for key 'pk01.PRIMARY'
			insert into pk01 value(null,'tom');-- 失败  Column 'id' cannot be null
			
			create table pk01(
				id int primary key,
				username  varchar(20),
				primary key (id)
			);-- 错误的 一张表只能有一个主键
			
		方式3：建表 之后，通过修改表结构添加约束
			create table pk02(
				id int,
				username varchar(20)
			);
			
			alter table pk02 add primary key(字段名1，字段名2..);
			alter table pk02 add primary key(id,username);
			
			insert into pk02 values(1,'tom');-- 成功
			insert into pk02 values(1,'tomcat');-- 成功
			insert into pk02 values(1,'tomcat');-- 失败
			
唯一约束：（了解）
	被修改过的字段唯一，对null不起作用
	方式1：建表的同时添加约束	格式：字段名称	字段类型	unique
		create table un(
			id int unique,
			username varchar(20) unique
		);
		
		insert into un value(10,'tom');-- 成功
		insert into un value(10,'jack');-- Duplicate entry '10' for key 'un.id'
		insert into un value(null,'jack');-- 成功
		insert into un value(null,'rose');-- 成功
		
	方式2：建表的同时在约束区域添加约束
		所有的字段声明完成之后，就是约束区域了
		unique(字段1，字段2...)
	方式3：建表之后，通过修改表结构添加约束
		alter table 表名 add unique(字段1，字段2);-- 添加的联合唯一
		alter table 表名 add unique(字段1);-- 给一个添加唯一
		alter table 表名 add unique(字段2);-- 给另一个添加唯一
		

		非空线束（了解）
			特点：被修饰过的字段非空
			方式：
				create table nn(
					id int not null,
					username varchar(20) not null
				);
				
				insert into nn values(null,'tom');-- 错误 Column 'id' cannot be null


////////////////////////////////////////////////////////
truncate  清空表	*
	格式：
		truncate 表名；干掉表，重新创建一张空表
	和delete from 区别
		delete 属于DML语句   truncate属于DDL语句
		delete 逐条删除	truncate干掉表，重新创建一张空表
		
		delete from user;
		
		select * from user;
		
		insert into user values(null,'jerry');
		
show create table user;
+-------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| Table | Create Table                                                                                                                                                                                              |
+-------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| user  | CREATE TABLE `user` (
  `id` int NOT NULL AUTO_INCREMENT,
  `username` varchar(20) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=6 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci |
+-------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
1 row in set (0.06 sec)
		
auto_increment	自增
	要求：
		1.被修饰的字段类型支持自增.	一般int
		2.被修饰的字段必须是一个key	一般是primary key
		
create table ai01(
	id varchar(10) auto_increment
);

-- 错误 Incorrect column specifier for column 'id'

create table ai01(
	id int auto_increment
);
-- 错误 Incorrect table definition; there can be only one auto column and it must be defined as a key
	
/////////////////////////////////////////
案例2-创建多表，可以描述表与表之间的关系
需求：
	把网上商城里面用的实体创建成表，并且将他们之间建立关系，
技术分析：
	sql
	
///////////////////////////////////////////
网上商城的实体：
	用户	订单	商品	分类
	
首页	手机数码	运动户外	电脑办公	家具家居	鞋靴箱包	图书音像	母婴孕婴	洗车用品
常见关系：
	一对多，用户和订单	分类和商品
	多对多.  订单和商品	学生和课程（一个学生可以学多个课程，一个课程可以由多个学生选择）
	一对一.丈夫和妻子
ER图可以描述实体与实体之间的关系
	实体用矩形表示
	属性用椭圆表示
	关系用菱形表示
	
	用户（user）
	id			username
	3			张三
	4			李四
	5			王五
	
	
	订单表（product_order)
	id			totalprice
	1			1314
	2			1314
	3			1314

一对多：
	用户和订单
	-- 创建用户表
		create table user(
			id int primary key auto_increment,
			username varchar(20)
		);
		
		
	-- 创建订单表
		create table product_order(
			id int primary key auto_increment,
			totalprice double,
			user_id int 
		);
		
为了保证数据的有效性和完整性，添加约束（外键约束）。
	在多表的一方添加外键约束
		格式：
			alter table 多表名称 add foreign key(外键名称) reference 一表名称(主键);
		例如：
			alter table product_order add foreign key(user_id) references user(id);
			
	insert into user values(6,'赵六');
	
	添加了外键约束之后有如下特点：
		1.主表中不能删除从表中已经引用的数据
		2.从表中不能添加主表中不存在的数据。
		
	insert into product_order values(null,305,8);
	
	开发中处理一对多：*
		在多表中添加一个外键，名称一般为主表的名称_id，字段类型一般和主表的主键的类型保持一致，
		为了保证数据的有效性和完整性，在多表的外键上添加外键线束即可。
		
////////////////////////////////////////////////////
多对多
	例子：商品和订单
	
	-- 创建商品表
	create table product(
		id int primary key auto_increment,
		name varchar(20),
		price double
	);
	create table orderitem(
		id int primary key auto_increment,
		oid int ,
		pid int
	);
	
	-- 添加外键约束
	alter table orderitem add foreign key(oid) references product_order(id);
	alter table orderitem add foreign key(pid) references product(pid);
	
	开发中处理多对多：*
		引入一张中间表，存放两张表的主键，一般会将两个字段设置为联合主键，
		这样就可以将多对多的关系拆分成两个一对多了。
		为了保证数据的有效性和完整性
			需要在中间表上添加两个外键约束即可
/////////////////////////////////////////////////////////
案例3-多表查询
技术分析：
	内连接：
	外连接：
	子查询

////////////////////////////////////////////////////////
笛卡尔积：了解
	多张表无条件的联合查询，没有任何意思
		select a.*,b.* from a,b;
		select user.*,product_order.* from user,product_order;
	内连接：*
		格式1：显式的内连接
			select a.*,b.* from a [inner] join b on ab的连接条件 ;
		格式2：隐式的内连接
			select a.*,b.* from a,b where ab的连接条件;
	外连接：*
		左外连接：
			select a.*,b.* from a left [outer] join b on 连接条件；
			意思：
				先展示join左边的（a）表的所有数据，根据条件 关联查询 join 右边的表（b），
				符合条件则展示出来，不符合以null值展示；
		右外连接：
			select a.*,b.* from a right [outer] join b on 连接条件；
			意思：
				先展示join右边的（b）表的所有数据，根据条件 关联查询 join 左边的表（a），
				符合条件则展示出来，不符合以null值展示；
			
	子查询：*
		一个查询依赖另一个查询。
		
练习：
	查询用户的订单，没有订单的用户不显示
		隐式内连接：
			select user.*,product_order.* from user,product_order 
			where user.id=product_order.user_id;
		显式内连接：
			select user.*,product_order.* from user inner join product_order 
			on user.id=product_order.user_id;
	查询所有用户的订单详情
		左外连接：user在左
				select user.*,product_order.* from user left join product_order 
				on user.id=product_order.user_id;
			
	查询所有订单的用户详情
		右外连接：product_order 在右
				select product_order.*,user.* from user right join product_order
				on user.id=product_order.user_id;
				select product_order.*,user.* from product_order left join user
				on user.id=product_order.user_id; 
				
练习：
	查看用户为张三的订单详情
		1.先查询张三的id
		select id from user where username='张三';//3
		2.select * from product_order where user_id=?;
		两个合二为一
			select * from product_order where user_id=
			(select id from user where username='张三');
	查询出订单的价格大于300的所有用户信息
		1.先查询出订单价格>300的用户的id
			select user_id from product_order where price>300;//(3,3,5,null)
		2.select * from user where id ??;
		两个全二为一：
		  select * from user where id in 
		  (select user_id from product_order where totalprice>300);
	查询订单价格大于300的订单信息及相关用户的信息。
		内连接：
		select product_order.*,user.* from product_order,user
		where 
		user.id=product_order.user_id
		and 
		product_order.totalprice>300; 
		
		select * from product_order where totalprice>300;//查询订单价格>300所有订单。
		
		子查询：是将一个查询的结果作为一张临时表
		select user.*,tmp.* from user,tmp where user.id=tmp.user_id;
		
		select user.*,tmp.* from user,
		(select * from product_order where totalprice>300)as tmp 
		where user.id=tmp.user_id;
		
	给表起别名
		格式：表 [as] 别名
		
/////////////////////////////////////////////////////////
上午回顾：
sql分类：
	DDL:
		对象：数据库和表
		关键词：create alter drop
		创建数据库：create datebase day0601;
		删除数据库：drop database day0601;
		
		use day0601;
		
		创建表：
			create table user(
				id int primary key auto_increment,
				username varchar(20)
			);
			
		修改表：
			alter table user rename to user10;
			alter table user add password varchar(20);
			alter table change password pwd varchar(20);
			alter table modify pwd int;
			alter table drop pwd;
		删除表
			drop table user;
	DML:
		操作对象：记录
		关键词：insert update delete
		
		插入:
			insert into user values(字段值1...);
			insert into user(字段1，字段2） values(字段值，字段值);
		更新：
			update user set 字段名=字段值，字段名1=字段值1 where 条件；
		删除：
			delete from user where 条件；
			
	DQL:
		select ... from user where 条件  group by 分组字段 order by 排序字段 asc|desc;
	DCL:
		
////////////////////////////////////////////
多表的创建，关系的创建
常见的关系：
	一对多
		在开发中，在多表的一方添加一个外键，外键的名称一般为主表的名称_id，字段类型一般和主表的主键的类型保持一致。
		为了保证数据的有效性和完整性，
			在多表的一方添加外键约束（不是必须的，也可以通过java程序来控制)
				格式：
					alter table 多表名称 add foreign key(外键名称)  references 主表(主键名称);
	多对多：
		在开发中，一般引入 一个中间表，在中间表中存放另外两张表的主键，这样就可以将多对多的关系拆分两个一对多的关系
		为了保证数据的有效性和完整性，
			在中间表上添加两个外键约束（不是必须的，也可以通过java程序来控制）
			
		外键约束的特点：
			1.主表中不删除从表中已引用的数据
			2.从表中不能添加主表中不存在的数据。 
	一对一：了解
		在开发中，例如：person idcard
			思路1：将两个实体合二为一
			思路2：在一个表上将这个表的主键设置外键且添加外键约束。
	
多表查询：
	内连接：
		显式的内连接
			select a.*,b.* from a inner join b on 连接条件；
		隐式的内连接
			select a.*,b.* from a,b where 连接条件 ;
	外连接
		左外连接
			select a.*,b.* from a left join b on 连接条件;
			展示a表所有数据，根据条件关联查询b表，满足条件展示，不满足以null值展示
	子查询
		给表起别名
			表 [as] 别名
			
	
	
