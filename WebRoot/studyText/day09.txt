回顾：
xml:
	可扩展的标签语言
	标签可以自定义
	作用：配置文件
	xml组成：
		声明  首先顶格写
		元素
			<xxx></xxx>
			<xx/>
			
		属性
			<xxx  attr="value">
		注释
			<!-- 注释内容-->
		CDATA 原样输出
			<![CDATA[
				....
			]]>
xml的解析：
	sax:逐行解析，只能查询
	dom:一次性将文档加载到内存，形成一棵树，可以进行curd操作
通过dom4j进行查询操作：
	1.导入jar包
	2.获取document
		Document doc=new SAXReader().read(文件路径);
	3.获取根节点
		Element root=doc.getRootElement();
	4.获取其他节点
		获取属性节点
			root.attributeValue("属性名")
		获取所有的子元素
			List<Element> list=root.elements()
		获取子元素的文本节点
			String text=ele.elementText("子元素名称")

扩展：xpath
	api:
		List<Element> selectNodes("表达式");
		Element selectSingleNode("表达式");
		
//////////////////////////////////////////////////////
xml约束：
	作用：规定文档中可以出现那些元素和属性  及他们出现的顺序
	分类：
		DTD和SCHEMA
	DTD:一个xml文档中只能有一个dtd约束
		只要在文档上面看到<!DOCTYPE>就说明使用的是dtd约束
		* ？ + ， | （）
	SCHEMA:一个xml文档中可以出现多个schema约束
		只要在xml文档中看到 xmlns
///////////////////////////////////////////////////////
tomcat
	web:网页或者资源
	资源有动态web资源和静态web资源
	动态的web开发技术：sevlet和jsp等等
	静态的web开发技术：html  css等
tomcat
	启动：bin/startup.bat
	退出：bin/shutdown.bat
	修改端口号：conf/server.xml
	存放项目目录：webapps
web项目目录
	myweb
		|
		|----html css 图片
		|
		|----WEB-INF(特点：浏览器直接访问不到，通过java程序可以)
		|       |
		|       |----lib
		|       |----classes
		|       |----web.xml(核心配置文件）
		|       |
		
///////////////////////////////////////////////////
发布方式：
	方式1：将项目放在webapps下
///////////////////////////////////////////////////
访问路径：
	http://主机：端口号/项目名称/资源路径
///////////////////////////////////////////////////

///////////////////////////////////////////////////
http:要求：掌握一些头信息
	超文本传输协议
		规定数据的格式
	浏览器往服务器发送――――请求
	服务器往浏览器回写――――响应
	
请求：
	组成部分：
		请求行  请求头  请求体
	请求行：请求信息的第一行
	请求头：请求信息的第二行到空行结束
	请求体：空行以下的内容
响应：

	
/////////////////////////////////////////////////
案例1-完成登录案例
需求：
	在页面上输入用户名和密码，提交到服务器上，服务器拿着用户名和密码去数据库中查找有无此用户
		若有用户，则提示登录成功
		若无此用户，则提示用户名密码不匹配
技术分析：
	表单：
	servlet
	请求（request)
	响应（response）
//////////////////////////////////////////////////////////
表单：
	收集用户数据
	所有的字段要想提交到服务器必须  有name属性
	提交的地址	action
	请求方式：post
///////////////////////////////////////////////////////////
servlet:
	动态的web开发技术，本质就是一个类，支行在服务器端的一个java小程序
	处理业务逻辑，生成动态web内容
编写一个Servlet步骤
	1.编写一个类
		a.继承HttpServlet
		b.重写doGet或者doPost方法
	2.编写配置文件（web-inf/web.xml)
		a.注册servlet
		b.绑定路径
	3.访问
		http://主机：端口号/项目名/路径
相关代码如下：
类：com.itheima.a_hello.HelloServlet
package com.itheima.a_hello;
import java.io.IOException; 

import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

public class HelloServlet extends HttpServlet {

	@Override
	protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
		System.out.println("请求已收到.......");
	}

}


<?xml version="1.0" encoding="UTF-8"?>
<web-app xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xmlns="http://java.sun.com/xml/ns/javaee" 
xsi:schemaLocation="http://java.sun.com/xml/ns/javaee 
http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd"
 id="WebApp_ID" version="2.5">
 <!--
 	a.注册servlet 使用servlet标签
 		servlet-name:给servlet起个名字全局唯一
 		servlce-class:存servlet的全限定名复制过来
 		
 --> 
  <servlet> 
    <servlet-name>HelloServlet</servlet-name>
    <servlet-class>com.itheima.a_hello.HelloServlet</servlet-class>
  </servlet>  
<!--
	b.绑定路径 使用servlet-mapping标签
		servlet-name:使用上面已起好的名字 建议复制
		url-pattern:访问路径 要求：目前必须以“/”开关唯一
-->
  <servlet-mapping>
    <servlet-name>HelloServlet</servlet-name>
    <url-pattern>/hello</url-pattern>
  </servlet-mapping>  
</web-app>	
	
类：com.itheima.b_request.RequestServlet 
package com.itheima.b_request;
import java.io.IOException; 

import javax.servlet.ServletException; 
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

public class RequestServlet extends HttpServlet{

	@Override
	protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
		//接受参数
		String value=request.getParameter("username");
		//往浏览器回写数据
		//response.getWriter().print("data:"+value);
		response.setContentType("text/html;charset=utf-8");
		response.getWriter().print("数据："+value);
		System.out.println("value="+value);
	}

}


<?xml version="1.0" encoding="UTF-8"?>
<web-app xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xmlns="http://java.sun.com/xml/ns/javaee" 
xsi:schemaLocation="http://java.sun.com/xml/ns/javaee 
http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd"
 id="WebApp_ID" version="2.5">
 <!--
 	a.注册servlet 使用servlet标签
 		servlet-name:给servlet起个名字全局唯一
 		servlce-class:存servlet的全限定名复制过来
 		
 --> 
  <servlet> 
    <servlet-name>HelloServlet</servlet-name>
    <servlet-class>com.itheima.a_hello.HelloServlet</servlet-class>
  </servlet>  
  <servlet> 
    <servlet-name>RequestServlet</servlet-name>
    <servlet-class>com.itheima.b_request.RequestServlet</servlet-class>
  </servlet>  
<!--
	b.绑定路径 使用servlet-mapping标签
		servlet-name:使用上面已起好的名字 建议复制
		url-pattern:访问路径 要求：目前必须以“/”开关唯一
-->
  <servlet-mapping>
    <servlet-name>HelloServlet</servlet-name>
    <url-pattern>/hello</url-pattern>
  </servlet-mapping>  
  <servlet-mapping>
    <servlet-name>RequestServlet</servlet-name>
    <url-pattern>/request</url-pattern>
  </servlet-mapping>  
</web-app>	

页面：index.html
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Insert title here</title>
</head>
<body>
	<a href="http://localhost:80/day09/request?username=tom">
	b_请求参数
	</a>
</body>
</html>
接受参数：格式：key=value
	String value=request.getParameter("key")
	例如：http://localhost/day09/hello?username=tom
		request.getParameter("username")就可以获取tom值
回写内容：
	response
	response.getWriter().print("success");
	处理响应数据中文乱码
	response.setContentType("text/html;charset=utf-8");//建议大家方法中的第一行
///////////////////////////////////////////////
步骤分析：
	1.先有数据库和表 
	2.复制页面
	3.创建servlet
	4.导入jar包：
		驱动 dbutils c3p0
	5.导入工具类和配置文件
		datasourceUtils
		c3p0-config.xml
	6.创建servlet(LoginServlet)
		接受用户名和密码
		调用service层（UserService)完成登录操作
		提示信息
	7.UserService
		login(username,password)
			调用dao
	8.dao
		通过用户名和密码查询数据库
		
///////////////////////////////////////////////
步骤分析：
	1.先有数据库和表
		create database day09;
		use day09;
		create table user(
			id int primary key auto_increment,
			username varchar(20),
			password varchar(20),
			email varchar(20),
			name varchar(20),
			sex varchar(10),
			birthday date,
			hobby varchar(50)
		);
		insert into user values
		(null,'tom','123','tom@126.com',
		'tom','1','1988-01-01',null);
		
/***
ORI-01-USER_ACCOUNT-V1.0-20210211
***/

CREATE TABLE USER_ACCOUNT(
USER_ACCOUNT_ID VARCHAR2(100) NOT NULL,
USERNAME VARCHAR2(100) NOT NULL,
PASSWORD VARCHAR2(100) NOT NULL,
EMAIL VARCHAR2(100) NULL,
NAME NVARCHAR2(100) NULL,
SEX VARCHAR2(10) NULL,
BIRTHDAY DATE,
HOBBY NVARCHAR2(100),
CONSTRAINT USER_ACCOUNT_ID_PK PRIMARY KEY (USER_ACCOUNT_ID)
);

COMMENT ON TABLE USER_ACCOUNT IS '用户账号表';
COMMENT ON COLUMN USER_ACCOUNT.USER_ACCOUNT_ID IS '用户账号ID';
COMMENT ON COLUMN USER_ACCOUNT.USERNAME IS '用户账号名';
COMMENT ON COLUMN USER_ACCOUNT.PASSWORD IS '用户账号密码';
COMMENT ON COLUMN USER_ACCOUNT.EMAIL IS 'EMAIL电子邮箱';
COMMENT ON COLUMN USER_ACCOUNT.NAME IS '用户名';
COMMENT ON COLUMN USER_ACCOUNT.SEX IS '性别';
COMMENT ON COLUMN USER_ACCOUNT.BIRTHDAY IS '出生日期';
COMMENT ON COLUMN USER_ACCOUNT.HOBBY IS '兴趣爱好'; 


/*
ORI-01-USER_ACCOUNT_ID_TRI-V1.0-20210211
*/
CREATE OR REPLACE TRIGGER USER_ACCOUNT_ID_TRI 
BEFORE INSERT ON USER_ACCOUNT 
FOR EACH ROW 
BEGIN
SELECT 
--'USER'||TO_NCHAR(USER_ID_AUTO.nextval) 
SYS_GUID() 
INTO :NEW.USER_ACCOUNT_ID 
FROM DUAL ;

END USER_ACCOUNT_ID_TRI
;

INSERT INTO USER_ACCOUNT
(USERNAME,PASSWORD,EMAIL,NAME,SEX,BIRTHDAY,HOBBY) 
VALUES (
'tom','123','tom@126.com',
		'tom','1',TO_DATE('1988-01-01','YYYY-MM-DD'),null
);

create table 		
		
	2.创建工程
	
	
	3.复制页面
		修改login.html
			给用户名和密码添加name属性
			修改表单的action属性
				action="http://localhost/day0901/"
			添加method属性
				method="post"
	4.导入jar包：
		驱动 dbutils c3p0
	5.导入工具类和配置文件
		datasourceUtils
		c3p0-config.xml
	6.创建servlet(LoginServlet:路径 /login)
		接受用户名和密码
		调用service层（UserService)完成登录操作
		提示信息
	7.UserService
		login(username,password)
			调用dao
	8.dao
		通过用户名和密码查询数据库
//////////////////////////////////////////
servlet总结：
servlet的体系结构：（了解）
	Servlet:接口
		|
	GenericServlet:抽象类
		|
	HttpServlet:抽象类
		|
	自定义servlet（在“java_ee_api_中英文对照版（田克传制作）
		|
	servlet常用方法：
		void init(ServletConfig config):初始化
		void service(ServletRequest request,ServletResponse response):服务 编写处理业务 逻辑
		void destroy():销毁
		
		String getServletName():获取当前servlet的(web.xml中servlet-name的值)名称
		
		ServletConfig getServletConfig():获取当前servlet的配置对象
		
	GenericServlet常用方法：
		除了service方法没有显示，其他都实现了
		空参的Init()  若我们自己想对servlet进行初始化操作，重写这个init()方法即可
	
	HttpServlet常用方法：
		service做了实现，把参数强转，调用了重载的service方法
			重载的service方法获取请求的方式，根据请求方式的不同调用相应的doXxx()方法。
		doGet和doPost方法
//////////////////////////////////////////////
servlet生命周期 ***（三颗星）
	void init(ServletConfig config):初始化
		*初始化方法 
		*执行者：服务器
		*执行次数：一次
		*执行时机：默认第一次访问 的时候
	void service(ServletRequest request,ServletResponse response):服务 编写处理业务 逻辑
	 	* 服务
		* 执行者：服务器
	 	* 执行次数：请求一次执行一次
	 	* 执行时机：请求来的时候
	void destroy():销毁
	 	* 销毁
	 	* 执行者：服务器
	 	* 执行次数：只执行一次
	 	* 执行时机：当servlet该移除时候或者服务器正常关闭的时候
		
	servlet是一个单实例多线程
	默认第一次访问的时候，服务器创建servlet，并调用init实现初始化操作，并调用一次service方法
	每当请求来的时候，服务器创建一个线程，调用service方法执行自己的业务逻辑。
	当servlet被移除时候或者服务器正常关闭的时候，服务器调用servlet的destroy()方法实现销毁操作。
/////////////////////////////
url-pattern的配置:★
	方式1:完全匹配  必须以"/"开始 例如: /hello /a/b/c
	方式2:目录匹配  必须"/"开始  以"*"结束   例如: /a/*  /*
	方式3:后缀名匹配 以"*"开始 以字符结尾 例如: *.jsp  *.do  *.action
	
	优先级:
		完全匹配>目录匹配>后缀名匹配
 练习:
	有如下的一些映射关系：
		Servlet1 映射到 /abc/* 
		Servlet2 映射到 /*
		Servlet3 映射到 /abc 
		Servlet4 映射到 *.do 
	问题：
	当请求URL为“/abc/a.html”，"/abc/*"和"/*"都匹配，哪个servlet响应
		Servlet引擎将调用Servlet1.
	当请求URL为"/abc"时，"/*"和"/abc"都匹配，哪个servlet响应
		Servlet引擎将调用Servlet3.
	当请求URL为"/abc/a.do"时，"/abc/*"和"*.do"都匹配，哪个servlet响应
		Serlet引擎将调用 Servlet1.
	当请求URL为"/a.do"时，"/*"和"*.do"都匹配，哪个servlet响应
		Servlet引擎将调用Servlet2.
	当请求URL为"/xxx/yyy/a.do"时，"/*"和"*.do"都匹配，哪个servlet响应
		Servlet引擎将调用Servlet2.
//////////////////////////////////////////
在servlet标签有一个子标签 load-on-startup
	作用：用来修改servlet的初始化时机
	取值：正整数	值越大优先级越低
<servlet>
	<servlet-name>default</servlet-name>
	<servlet-class>org.apache.catalina.servlets.DefaultServlet</servlet-class>
	<init-param>
		<param-name>debug</param-name>
		<param-value>0</param-value>
	</init-param>
	<init-param>
		<param-name>listings</param-name>
		<param-value>false</param-value>
	</init-param>
	<load-on-startup>1</load-on-startup>
</servlet>
当我们 的配置文件 里面没有指定配置的话，会查找tomcat的web.xml,
	若请求我们自己的项目处理不了，tomcat的默认的servlet会帮我们处理信息
//////////////////////////////////////////////
路径的写法：
	相对路径：
		当前路径	./	或者	什么都不写
		上一级路径	../
	绝对路径：（我们使用）
		带主机和协议的绝对路径（访问站外资源） 
			http://www.itheima.com/xxxx
			http://localhost:80/day09/hello
		不带主机和协议的绝对路径
			/day09/hello(经常使用)
///////////////////////////////////////
案例2-当我们登录失败，提示“用户名密码不匹配”，3秒以后跳转到登录页面
技术分析：
	定时刷新
常见的响应头-refresh
	响应头的格式：
		refresh:秒数；url=跳转的路径
	设置响应头：
		response.setHeader(String key,String value);设置字符串形式的响应头
		response.addHeader(String key,String value);追加响应头，若之前设置过这个头，则追加；若没有设置过，则设置。
	设置定时刷新：
		response.setHeader("refresh","3;url=/day0901/login.html");
步骤分析：
	登录失败之后，修改业务逻辑
		打印之后添加一个头信息即可
///////////////////////////////////////
案例3-统计登录成功的总人次，
需求：
	在一个用户登录成功之后，获取之前登录成功总人次，将次数+1，再访问另一个
	servlet的时候，显示登录成功的总人次。
技术 分析：
	ServletContext
//////////////////////////////////////////////////
ServletContext
	上下文（全局管理者）
	常用的方法：
		setAttribute(String key,Object value);//设置参数
		Object getAttribute(String key);//获取值
		removeAttribute(String key);//移除值
获取全局管理者：
	(this.)getServletContext();
////////////////////////////////////////////
步骤分析：
	1.在项目启动的时候，初始化登录次数。
		在loginServlet的init()方法中获取全局管理都，将值初始化为0，放入servletContext上。
		
	2.登录成功之后，在loginServlet中获取全局管理者，获取登录成功的总次数
	3.然后将次数+1，然后将值设置回去
	4.当访问showServlet的时候，获取全局管理者，获取登录成功的总次数，然后在页面上打印出来即可。
	
	
	
			
			


///////////////////////////////////////////	
ServletConfig:(了解)
	servlet配置对象
	作用：
		1.获取当前servlet的名称
		2.获取当前servlet的初始化参数
		3.获取全局的管理者
	方法：
		String getServletName();获取当前servlet的名称（web.xml配置的servlet-name)
		获取初始化参数
		getInitParameter(String key)通过名称获取指定的参数值
		Enumeration getInitParameterNames():获取所有的参数名称
			初始化参数是放在web.xml文件
				servlet标签下子标签init-param
				
		（一w星）getServletContext():获取全局管理者
	servletConfig 是由服务器创建的，在创建servlet的同时也创建了它，
	通过servlet的init()将configο鬟foservlet，由servlet的
	getServletConfig方法@取。
///////////////////////////////////////////////////////
ServletContext:理解
	上下文（全局管理者）
	一目的引用.代表了前目。
	目拥r候，服掌槊恳Web目建一ServletContextο蟆
	目被移除的r候或者服掌麝P]的r候servletContextNS。
	作用：
		1.@取全局的初始化
		2.共享Y源（xxxAttribute,get/set）
		3.@取文件Y源
		4.其他操作
	@取servletContext:
		方式1：了解
			getServletConfig().getServletContext()
		方式2：
			getServletContext()
	常用方法：
		1.了解
			String getInitParameter(String key):
			通过名称获取指定的参数值
			Enumeration getInitParameterName():
			获取所有的参数名称
			在根标签下有一个context-param子标签用来存放初始化参数
				<context-param>
					<param-name>encoding</param-name>
					<param-value>utf-8</param-value>
				</context-param>
		2.xxxAttribute
		3.
			String tomcatPath=getRealPath(String path):
			获取文件部署到tomcat上的真实路径(带tomcat路径)。
			context.getRealPath("/")=D:\ProgramFiles\Workspaces\workspace\Tomcat8.0.33\webapps\Day29\
			InputStream getResouceAsStream(String path):以流的形式返回一个文件。
		4.获取文件的mime类型		大类型/小类型
			String str=getMimeType(String 文件名称)
/////////////////////////////////////////////////////////
域ο螅海ㄈw星）
	servletContext
	成map集合
		常用方法：
			xxxAttribute()
	servletContext建和NS		
	目拥r候，服掌槊恳Web目建一ServletContextο蟆
	目被移除的r候或者服掌麝P]的r候servletContextNS。
	存放：
		共享的		
/////////////////////////////////////////////////////
@取文件的路剑
	通^加d 器@取文件：2.txt 放在classes目 下
		.class.getClassLoader().getResource("2.txt").getPath();
		
///////////////////////////////////////////
上午回：
http:超文本鬏fh
	求：
	：
servlet:（一w星）
	本|上就是一，\行在服掌鞫说囊java小程序，生成Bweb热萏理I者。
servlet:
	1.一 ^承了HttpServlet 重了doGet()或者doPost()
	2.配置文件
		]servlet
			<servlet>
				<servlet-name>oservlet起名字  名字唯一</servlet-name>
				<servlet-class>servlet的全限定名</servlet-class>
			</servlet>
		定路
			<servlet-mapping>
				<servlet-name>oservlet起名字 名字唯一</servlet-name>
				<url-pattern>L路  目前都是以"/"_始</url-pattern>
			</servlet-mappint>
	3.L路剑
		http://主C:端口/目名/路
servlet的w系Y：
	所有的servlet^承HttpServlet g接的F了Servlet接口
HttpServlet中的方法：
	sevice(ServletRequest request,ServletResponse response):在@方法中 D，{用了重dservice方法
		service(HttpServletRequest request,HttpServletResponse response):
		@取求的方式，根求方式的不同{用相doxxx()
	doGet和doPost方法：用硖理我自己I者
	
servlet的生命L期（三w星）

url-pattern的配置：
	完全匹配>目匹配>後Y名匹配
	
load-on-startup:修改servlet的初始化rC

若我自己的目理不了求，服掌魃嫌幸默J的servlet臀理。
//////////////////////////////////////////
servletConfig:
	servlet的配置ο螅
	@取servlet名Q	初始化
	@取全局管理者（一w星）	getServletContext()
//////////////////////////////////////////
ServletContext:
	上下文：
	作用：
		1.@取全局的初始化
			getInitParameter("key")
		2.共享Y源（域ο螅
			xxxAttribute()
		3.@取Y源
			getRealPath("/1.txt"):@取的是目l训椒掌魃衔恢玫母目 
			getResourceAsStream("/1.txt"):以流的形式返回一文件 
		4.@取文件mime型
			getMimeType(文件名Q) 
域ο螅
	servletContext
	建：
	NS：
	
	
			
		
	
	
	
	
	
	
	
	
		
	